<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VR Geburtstagsgeschenk</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #000;
        }

        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-size: 16px;
            z-index: 100;
            pointer-events: none;
        }

        #startButton {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px 40px;
            font-size: 20px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            z-index: 200;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        #startButton:hover {
            background: #45a049;
        }

        #vrButton {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 15px 30px;
            font-size: 18px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            z-index: 100;
            display: none;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        #vrButton:hover {
            background: #0b7dda;
        }

        #vrButton:hover {
            background: #0b7dda;
        }

        #godModeButton {
            position: absolute;
            bottom: 80px;
            /* Above the VR button */
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            font-size: 16px;
            background: #FF5722;
            /* Deep Orange */
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            z-index: 150;
            display: none;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        #godModeButton:hover {
            background: #E64A19;
        }
    </style>
</head>

<body>
    <div id="info">Schaue dich um und bewege dich zur TÃ¼r!</div>

    <button id="startButton">Erlebnis starten</button>
    <button id="godModeButton">God Mode: OFF</button>
    <button id="vrButton">VR-Modus starten</button>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { VRButton } from 'three/addons/webxr/VRButton.js';

        // --- Inline DeviceOrientationControls Implementation ---
        class DeviceOrientationControls {
            constructor(object) {
                this.object = object;
                this.object.rotation.reorder("YXZ");
                this.enabled = true;
                this.deviceOrientation = {};
                this.screenOrientation = 0;
                this.alphaOffset = 0;

                this.onDeviceOrientationChangeEvent = (event) => {
                    this.deviceOrientation = event;
                };

                this.onScreenOrientationChangeEvent = () => {
                    this.screenOrientation = window.orientation || 0;
                };

                window.addEventListener('deviceorientation', this.onDeviceOrientationChangeEvent, false);
                window.addEventListener('orientationchange', this.onScreenOrientationChangeEvent, false);

                this.onScreenOrientationChangeEvent();
            }

            update() {
                if (!this.enabled) return;
                const device = this.deviceOrientation;
                if (device) {
                    const alpha = device.alpha ? THREE.MathUtils.degToRad(device.alpha) + this.alphaOffset : 0;
                    const beta = device.beta ? THREE.MathUtils.degToRad(device.beta) : 0;
                    const gamma = device.gamma ? THREE.MathUtils.degToRad(device.gamma) : 0;
                    const orient = this.screenOrientation ? THREE.MathUtils.degToRad(this.screenOrientation) : 0;

                    this.setObjectQuaternion(this.object.quaternion, alpha, beta, gamma, orient);
                }
            }

            setObjectQuaternion(quaternion, alpha, beta, gamma, orient) {
                const zee = new THREE.Vector3(0, 0, 1);
                const euler = new THREE.Euler();
                const q0 = new THREE.Quaternion();
                const q1 = new THREE.Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5));

                euler.set(beta, alpha, -gamma, 'YXZ');
                quaternion.setFromEuler(euler);
                quaternion.multiply(q1);
                quaternion.multiply(q0.setFromAxisAngle(zee, -orient));
            }

            dispose() {
                window.removeEventListener('deviceorientation', this.onDeviceOrientationChangeEvent);
                window.removeEventListener('orientationchange', this.onScreenOrientationChangeEvent);
            }
        }
        // -------------------------------------------------------

        let scene, camera, renderer, reticle;
        let userGroup;
        let deviceControls;
        let ground, teleportMarker;
        let canTeleport = false;
        let boxOpened = false;
        let shelfOpened = false;
        let vrSupported = false;
        let isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);

        let interactables = [];
        let colliders = []; // Walls, etc.
        let giftBox, giftBoxLid, shelfDoor;
        let cyberOpened = false;
        let interactionMarker;
        let hoverState = { type: 'none', object: null, point: null };
        let houses = [];

        const startButton = document.getElementById('startButton');
        const vrButton = document.getElementById('vrButton');
        const godModeButton = document.getElementById('godModeButton');
        const info = document.getElementById('info');
        let isGodMode = false;

        let isInit = false;
        startButton.addEventListener('click', () => {
            if (isInit) return;
            isInit = true;
            init();
        });

        // texture generation
        const textures = {};

        function generateTextures() {
            // 1. Neon Grid / Cobblestone Floor
            const canvasFloor = document.createElement('canvas');
            canvasFloor.width = 512; canvasFloor.height = 512;
            const ctxFloor = canvasFloor.getContext('2d');
            ctxFloor.fillStyle = '#111';
            ctxFloor.fillRect(0, 0, 512, 512);
            ctxFloor.strokeStyle = '#0ff';
            ctxFloor.lineWidth = 2;
            ctxFloor.shadowBlur = 10;
            ctxFloor.shadowColor = '#0ff';
            for (let i = 0; i <= 512; i += 64) {
                ctxFloor.beginPath(); ctxFloor.moveTo(i, 0); ctxFloor.lineTo(i, 512); ctxFloor.stroke();
                ctxFloor.beginPath(); ctxFloor.moveTo(0, i); ctxFloor.lineTo(512, i); ctxFloor.stroke();
            }
            textures.floor = new THREE.CanvasTexture(canvasFloor);
            textures.floor.wrapS = THREE.RepeatWrapping;
            textures.floor.wrapT = THREE.RepeatWrapping;
            textures.floor.repeat.set(10, 10);

            // 2. Rustic Wood
            const canvasWood = document.createElement('canvas');
            canvasWood.width = 512; canvasWood.height = 512;
            const ctxWood = canvasWood.getContext('2d');
            ctxWood.fillStyle = '#3e2723';
            ctxWood.fillRect(0, 0, 512, 512);
            for (let i = 0; i < 50; i++) {
                ctxWood.strokeStyle = '#281a15';
                ctxWood.lineWidth = Math.random() * 5 + 1;
                ctxWood.beginPath();
                ctxWood.moveTo(0, Math.random() * 512);
                ctxWood.bezierCurveTo(150, Math.random() * 512, 350, Math.random() * 512, 512, Math.random() * 512);
                ctxWood.stroke();
            }
            textures.wood = new THREE.CanvasTexture(canvasWood);

            // 3. Neon Glyphs
            const canvasNeon = document.createElement('canvas');
            canvasNeon.width = 128; canvasNeon.height = 128;
            const ctxNeon = canvasNeon.getContext('2d');
            ctxNeon.fillStyle = '#000';
            ctxNeon.fillRect(0, 0, 128, 128);
            ctxNeon.strokeStyle = '#f0f';
            ctxNeon.lineWidth = 5;
            ctxNeon.shadowBlur = 15;
            ctxNeon.shadowColor = '#f0f';
            ctxNeon.strokeRect(10, 10, 108, 108);
            ctxNeon.font = '80px Arial';
            ctxNeon.fillStyle = '#f0f';
            ctxNeon.textAlign = 'center';
            ctxNeon.textBaseline = 'middle';
            // ctxNeon.fillText('RUN', 64, 64);
            textures.neon = new THREE.CanvasTexture(canvasNeon);

            // 4. Witcher Sprite
            const canvasWitcher = document.createElement('canvas');
            canvasWitcher.width = 256; canvasWitcher.height = 512;
            const ctxW = canvasWitcher.getContext('2d');
            ctxW.clearRect(0, 0, 256, 512);
            ctxW.fillStyle = '#222';
            ctxW.fillRect(80, 150, 96, 200);
            ctxW.fillStyle = '#ffccaa';
            ctxW.fillRect(100, 80, 56, 70);
            ctxW.fillStyle = '#eee';
            ctxW.fillRect(90, 80, 76, 40);
            ctxW.fillRect(90, 80, 20, 100);
            ctxW.fillStyle = '#aaa';
            ctxW.fillRect(180, 100, 10, 250);
            ctxW.fillRect(66, 100, 10, 250);
            ctxW.fillStyle = '#fb0';
            ctxW.fillRect(110, 110, 10, 6);
            ctxW.fillRect(136, 110, 10, 6);
            textures.witcher = new THREE.CanvasTexture(canvasWitcher);

            // 5. Johnny Silverhand Image (Load from file)
            const loader = new THREE.TextureLoader();
            textures.johnny = loader.load('johnny.png');
            textures.johnny.colorSpace = THREE.SRGBColorSpace;
        }

        async function init() {
            generateTextures();
            startButton.style.display = 'none';

            if (navigator.xr) {
                vrSupported = await navigator.xr.isSessionSupported('immersive-vr');
            }

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050510);
            scene.fog = new THREE.FogExp2(0x050510, 0.02);

            userGroup = new THREE.Group();
            scene.add(userGroup);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = 1.6; // Local height
            userGroup.add(camera);
            userGroup.position.set(0, 0, 10); // Start position

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.xr.enabled = true;
            renderer.shadowMap.enabled = true;
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);

            // WebXR Controller Input for "Mouse Click" via VR Viewer
            const controller = renderer.xr.getController(0);
            controller.addEventListener('select', onMouseClick);
            scene.add(controller);

            if (vrSupported) {
                const vrBtn = VRButton.createButton(renderer);
                vrBtn.style.bottom = '20px';
                vrBtn.style.left = '50%';
                vrBtn.style.transform = 'translateX(-50%)';
                document.body.appendChild(vrBtn);
                info.textContent = 'Starte den VR-Modus und schaue dich um!';
            } else if (isMobile) {
                vrButton.style.display = 'none';
                info.textContent = 'Bewege dein Handy um dich umzusehen! Tippe zum Laufen.';
                if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                    DeviceOrientationEvent.requestPermission()
                        .then(response => {
                            if (response == 'granted') {
                                deviceControls = new DeviceOrientationControls(camera);
                            }
                        })
                        .catch(console.error);
                } else {
                    deviceControls = new DeviceOrientationControls(camera);
                }
            } else {
                vrButton.style.display = 'block';
                vrButton.textContent = 'Desktop Modus Aktiv';
                vrButton.style.display = 'block';
                vrButton.textContent = 'Desktop Modus Aktiv';
                godModeButton.style.display = 'block';
                godModeButton.addEventListener('click', () => {
                    isGodMode = !isGodMode;
                    godModeButton.textContent = isGodMode ? 'God Mode: ON' : 'God Mode: OFF';
                    godModeButton.style.background = isGodMode ? '#4CAF50' : '#FF5722';
                });
                info.textContent = 'Nutze Maus (Klick+Ziehen) und WASD/Pfeile zum Bewegen';
            }

            const ambientLight = new THREE.AmbientLight(0x4040a0, 1.0);
            scene.add(ambientLight);

            const sunLight = new THREE.DirectionalLight(0xff00ff, 1.5);
            sunLight.position.set(-10, 20, -10);
            sunLight.castShadow = true;
            scene.add(sunLight);

            const pointLight = new THREE.PointLight(0x00ffff, 2, 20);
            pointLight.position.set(0, 5, 5);
            scene.add(pointLight);

            createEnvironment();
            createVillage();
            createDecorations();
            createReticle();

            setupDesktopControls();

            renderer.setAnimationLoop(animate);
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('click', onMouseClick);
            window.addEventListener('touchstart', onMouseClick); // Fallback for some VR viewers
            window.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') onMouseClick();
            });
        }

        function onMouseClick() {
            if (hoverState.type === 'teleport' && canTeleport && teleportMarker.visible) {
                const target = teleportMarker.position;
                userGroup.position.set(target.x, 0, target.z);
            } else if (hoverState.type === 'interact') {
                const object = hoverState.object;
                const type = object.userData.type;
                if (type === 'door') {
                    // Remove door frame if linked
                    if (object.userData.frame) {
                        const frame = object.userData.frame;
                        frame.visible = false;
                        if (frame.parent) frame.parent.remove(frame);
                        if (frame.geometry) frame.geometry.dispose();
                        if (frame.material) frame.material.dispose();
                    }
                    // Remove door panel
                    object.visible = false;
                    object.scale.set(0, 0, 0); // Shrink to zero
                    object.position.set(0, -1000, 0); // Teleport to hell
                    if (object.parent) object.parent.remove(object);
                    if (object.geometry) object.geometry.dispose();
                    if (object.material) object.material.dispose();
                    // Remove from interactables and colliders
                    interactables = interactables.filter(o => o !== object);
                    colliders = colliders.filter(o => o !== object);
                    // Reset hover state to prevent double clicks
                    hoverState = { type: 'none', object: null, point: null };
                    interactionMarker.visible = false;
                } else if (type === 'gift') {
                    openGift();
                } else if (type === 'shelf') {
                    openShelf();
                } else if (type === 'cyber') {
                    openCyber(object);
                }
            }
        }

        function createEnvironment() {
            const groundGeometry = new THREE.PlaneGeometry(100, 100);
            const groundMaterial = new THREE.MeshStandardMaterial({
                map: textures.floor,
                roughness: 0.2,
                metalness: 0.6
            });
            ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            scene.add(ground);

            createTeleportMarker();
            createInteractionMarker();


            const particlesGeom = new THREE.BufferGeometry();
            const particleCount = 200;
            const positions = new Float32Array(particleCount * 3);
            for (let i = 0; i < particleCount * 3; i++) {
                positions[i] = (Math.random() - 0.5) * 60;
                if (i % 3 === 1) positions[i] = 10 + Math.random() * 20; // Stars only high up (10-30 units)
            }
            particlesGeom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const particlesMat = new THREE.PointsMaterial({ color: 0x00ffff, size: 0.2, transparent: true, opacity: 0.8 });
            const particles = new THREE.Points(particlesGeom, particlesMat);
            scene.add(particles);
        }

        function isPositionValid(x, z) {
            for (let h of houses) {
                // Convert (x,z) to House Local Space
                const dx = x - h.x;
                const dz = z - h.z;
                // Rotate back by -h.rot
                const cos = Math.cos(-h.rot);
                const sin = Math.sin(-h.rot);
                const lx = dx * cos - dz * sin;
                const lz = dx * sin + dz * cos;
                // House is roughly 4x4.
                // 1. Inside House: +/- 2.5 margin
                if (Math.abs(lx) < 2.5 && Math.abs(lz) < 2.5) return false;
                // 2. In front of House (Door is at local z=2): Zone width 4, len 10
                // Front means positive Z (where door is).
                if (Math.abs(lx) < 2.5 && lz > 2 && lz < 12) return false;
            }
            return true;
        }

        function createVillage() {
            createHouse(0, 0, -5, 0, false, false, true); // Middle House -> Johnny
            createHouse(-10, 0, 0, Math.PI / 4, false, true, false);
            createHouse(12, 0, -2, -Math.PI / 6, false, false, false);
            createHouse(-8, 0, -15, Math.PI / 3, true, false, false);
        }

        function createDecorations() {
            // 1. Neon Crystals / Spikes
            const spikeGeom = new THREE.ConeGeometry(0.2, 1.5, 4);
            const spikeMat = new THREE.MeshStandardMaterial({
                color: 0xff00ff,
                emissive: 0xff00ff,
                emissiveIntensity: 1.5,
                roughness: 0.1,
                metalness: 0.8
            });

            for (let i = 0; i < 25; i++) {
                const spike = new THREE.Mesh(spikeGeom, spikeMat);
                // Random position around the map
                const r = 10 + Math.random() * 30; // 10 to 40 radius
                const theta = Math.random() * Math.PI * 2;
                const x = r * Math.cos(theta);
                const z = r * Math.sin(theta);

                if (!isPositionValid(x, z)) continue;

                spike.position.set(x, 0.75, z);
                spike.rotation.x = (Math.random() - 0.5) * 0.5; // Slight tilt
                spike.rotation.z = (Math.random() - 0.5) * 0.5;
                scene.add(spike);
                colliders.push(spike); // Make them solid
            }

            // 2. Low Poly Rocks
            const rockGeom = new THREE.DodecahedronGeometry(1, 0); // Low poly
            const rockMat = new THREE.MeshStandardMaterial({
                color: 0x444444,
                roughness: 0.9,
                metalness: 0.1
            });

            for (let i = 0; i < 20; i++) {
                const rock = new THREE.Mesh(rockGeom, rockMat);
                // Scatter, some near spawn
                const x = (Math.random() - 0.5) * 60;
                const z = (Math.random() - 0.5) * 60;

                // Keep clear of direct start area (0,0,10)
                if ((Math.abs(x) < 2 && Math.abs(z - 10) < 2) || !isPositionValid(x, z)) continue;

                const s = 0.8 + Math.random() * 1.5;
                rock.scale.set(s, s * 0.7, s);
                rock.position.set(x, s * 0.3, z); // Partially buried
                rock.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);

                scene.add(rock);
                colliders.push(rock);
            }

            // 3. Floating Cyber-Cubes nearby
            const cubeGeom = new THREE.BoxGeometry(0.4, 0.4, 0.4);
            const cubeMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true });

            for (let i = 0; i < 15; i++) {
                const cube = new THREE.Mesh(cubeGeom, cubeMat);
                // Near spawn area mostly
                const x = (Math.random() - 0.5) * 20;
                const z = 10 + (Math.random() - 0.5) * 20;

                if (!isPositionValid(x, z)) continue;

                cube.position.set(x, 1.5 + Math.random() * 3, z);
                cube.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, 0);
                scene.add(cube);
            }
            createTrees();
        }

        function createTrees() {
            const trunkGeom = new THREE.CylinderGeometry(0.2, 0.3, 1.5, 8);
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x5D4037, roughness: 0.9 }); // Brown
            const leavesGeom = new THREE.ConeGeometry(1.5, 3, 8);
            const leavesMat = new THREE.MeshStandardMaterial({ color: 0x1B5E20, roughness: 0.8 }); // Dark Green

            for (let i = 0; i < 30; i++) {
                const treeGroup = new THREE.Group();
                const trunk = new THREE.Mesh(trunkGeom, trunkMat);
                trunk.position.y = 0.75; // Half of 1.5
                trunk.castShadow = true;
                trunk.receiveShadow = true;
                treeGroup.add(trunk);
                colliders.push(trunk);

                const leaves = new THREE.Mesh(leavesGeom, leavesMat);
                leaves.position.y = 2.25; // 1.5 + 1.5/2 = 2.25? No. trunk top at 1.5. cone 3 high. cone center at 1.5. So 1.5 + 1.5 = 3.0?
                // Trunk height 1.5. Center at 0.75. Top at 1.5.
                // Cone height 3. Center needs to be at 1.5 + 1.5 = 3. 
                // Wait. Cone origin is center. 
                leaves.position.y = 2.25;
                leaves.castShadow = true;
                leaves.receiveShadow = true;
                treeGroup.add(leaves);

                // Random placement, avoid spawn center
                const r = 15 + Math.random() * 40; // 15 to 55 distance
                const theta = Math.random() * Math.PI * 2;
                const tx = r * Math.cos(theta);
                const tz = r * Math.sin(theta);
                if (!isPositionValid(tx, tz)) {
                    i--; // Retry
                    continue;
                }
                treeGroup.position.set(tx, 0, tz);

                // Random scale
                const s = 0.8 + Math.random() * 0.5;
                treeGroup.scale.set(s, s, s);

                scene.add(treeGroup);
            }
        }

        function createHouse(x, y, z, rotation, isMain, isSecret, isCyber) {
            houses.push({ x: x, z: z, rot: rotation });
            const houseGroup = new THREE.Group();
            const wallMaterial = new THREE.MeshStandardMaterial({ map: textures.wood });
            const darkMaterial = new THREE.MeshStandardMaterial({ color: 0x1a1a1a });

            // -- Hollow House Construction --
            const wallThick = 0.2;
            const houseW = 4;
            const houseH = 3;
            const houseD = 4;

            const createWall = (w, h, d, px, py, pz) => {
                const wall = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), wallMaterial);
                wall.position.set(px, py, pz);
                wall.castShadow = true;
                wall.receiveShadow = true;
                houseGroup.add(wall);
                colliders.push(wall);
                return wall;
            };

            // 1. Back Wall
            createWall(houseW, houseH, wallThick, 0, houseH / 2, -houseD / 2 + wallThick / 2);

            // 2. Side Walls (fitting between front/back faces effectively, or just inside)
            // Let's make sides fit between front Z and back Z extents logic
            const sideD = houseD - 2 * wallThick;
            createWall(wallThick, houseH, sideD, -(houseW / 2 - wallThick / 2), houseH / 2, 0); // Left
            createWall(wallThick, houseH, sideD, (houseW / 2 - wallThick / 2), houseH / 2, 0);  // Right

            // 3. Front Wall segments (with door gap)
            const doorW = 1.6;
            const doorH = 2.2;
            const frontSideW = (houseW - doorW) / 2; // 1.2

            // Front Left
            createWall(frontSideW, houseH, wallThick, -(houseW / 2 - frontSideW / 2), houseH / 2, houseD / 2 - wallThick / 2);
            // Front Right
            createWall(frontSideW, houseH, wallThick, (houseW / 2 - frontSideW / 2), houseH / 2, houseD / 2 - wallThick / 2);
            // Front Header
            const headerH = houseH - doorH;
            createWall(doorW, headerH, wallThick, 0, doorH + headerH / 2, houseD / 2 - wallThick / 2);

            // Roof
            const roof = new THREE.Mesh(new THREE.ConeGeometry(3.5, 2, 4), darkMaterial);
            roof.position.y = 4;
            roof.rotation.y = Math.PI / 4;
            houseGroup.add(roof);

            // Door Frame (Visual Only)
            const doorFrame = new THREE.Mesh(new THREE.BoxGeometry(1.6, 2.2, 0.2), new THREE.MeshBasicMaterial({ map: textures.neon }));
            doorFrame.position.set(0, 1.1, 2.01);
            houseGroup.add(doorFrame);

            // Create actual door panel (removable)
            const doorPanel = new THREE.Mesh(new THREE.BoxGeometry(1.4, 2.0, 0.1), new THREE.MeshStandardMaterial({ map: textures.wood, color: 0x664422 }));
            doorPanel.position.set(0, 1.0, 2.01);
            doorPanel.userData = { type: 'door', frame: doorFrame };
            houseGroup.add(doorPanel);

            interactables.push(doorPanel);
            colliders.push(doorPanel);

            if (isMain) {
                createTableAndGift(houseGroup);
            } else if (isSecret) {
                createSecretShelf(houseGroup);
            } else if (isCyber) {
                createCyberpunkConsole(houseGroup);
            }

            houseGroup.position.set(x, y, z);
            houseGroup.rotation.y = rotation;
            scene.add(houseGroup);
        }

        // ... (createTableAndGift and createSecretShelf remain same) ...

        function createCyberpunkConsole(parentGroup) {
            const consoleGroup = new THREE.Group();

            // Base module
            const base = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1, 0.8), new THREE.MeshStandardMaterial({ map: textures.neon, color: 0x333333 }));
            base.position.y = 0.5;
            consoleGroup.add(base);

            // Screen / Lid
            const lidGroup = new THREE.Group();
            lidGroup.position.set(0, 1.0, -0.4); // Hinge at back

            const lid = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.1, 0.8), new THREE.MeshStandardMaterial({ map: textures.neon, emissive: 0x222222 }));
            lid.position.set(0, 0, 0.4); // Offset so it rotates from edge
            lidGroup.add(lid);

            consoleGroup.add(lidGroup);

            // Johnny Sprite (Hidden initially)
            const spriteMat = new THREE.SpriteMaterial({ map: textures.johnny });
            const johnnySprite = new THREE.Sprite(spriteMat);
            johnnySprite.scale.set(1.5, 1.5, 1); // Square aspect ratio
            johnnySprite.position.set(0, 1.5, 0);
            johnnySprite.visible = false;
            consoleGroup.add(johnnySprite);

            consoleGroup.position.set(0, 0, 0);
            parentGroup.add(consoleGroup);

            // Interaction Tag
            lid.userData = { type: 'cyber', parent: consoleGroup, lid: lidGroup, sprite: johnnySprite };
            interactables.push(lid);
        }

        function createTableAndGift(parentGroup) {
            const table = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.8, 1), new THREE.MeshStandardMaterial({ map: textures.wood }));
            table.position.set(0, 0.4, 0);
            parentGroup.add(table);

            const boxGroup = new THREE.Group();
            const boxMat = new THREE.MeshStandardMaterial({ color: 0xff0044, roughness: 0.3 });
            const lidMat = new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.8 });

            giftBox = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), boxMat);
            boxGroup.add(giftBox);

            giftBoxLid = new THREE.Mesh(new THREE.BoxGeometry(0.55, 0.1, 0.55), lidMat);
            giftBoxLid.position.y = 0.25;
            boxGroup.add(giftBoxLid);

            boxGroup.position.set(0, 1.0, 0);
            parentGroup.add(boxGroup);

            giftBox.userData = { type: 'gift', parent: boxGroup };
            interactables.push(giftBox);
        }

        function createSecretShelf(parentGroup) {
            const shelfGroup = new THREE.Group();
            // Make body a back panel so there is space inside
            const body = new THREE.Mesh(new THREE.BoxGeometry(1, 1.5, 0.1), new THREE.MeshStandardMaterial({ map: textures.wood, color: 0x888888 }));
            body.position.z = -0.2; // Move back
            shelfGroup.add(body);

            const doorGroup = new THREE.Group();
            doorGroup.position.set(-0.45, 0, 0.26);

            shelfDoor = new THREE.Mesh(new THREE.BoxGeometry(0.9, 1.4, 0.1), new THREE.MeshStandardMaterial({ map: textures.wood }));
            shelfDoor.position.set(0.45, 0, 0);
            doorGroup.add(shelfDoor);

            shelfGroup.add(doorGroup);
            shelfDoor = doorGroup; // Override for animation

            const spriteMat = new THREE.SpriteMaterial({ map: textures.witcher });
            const witcherSprite = new THREE.Sprite(spriteMat);
            witcherSprite.scale.set(0.7, 1.4, 1);
            witcherSprite.position.set(0, 0, 0.0); // Move back to 0.0 (was 0.3)
            witcherSprite.name = 'witcherSprite'; // Add name for access
            shelfGroup.add(witcherSprite);

            shelfGroup.position.set(0, 1.2, 0);
            parentGroup.add(shelfGroup);

            doorGroup.children[0].userData = { type: 'shelf', parent: shelfGroup };
            interactables.push(doorGroup.children[0]);
        }

        function createReticle() {
            const reticleGeometry = new THREE.RingGeometry(0.02, 0.04, 32);
            const reticleMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, opacity: 0.8, transparent: true });
            reticle = new THREE.Mesh(reticleGeometry, reticleMaterial);
            reticle.visible = false;
            scene.add(reticle);
        }

        function createTeleportMarker() {
            const group = new THREE.Group();

            // Glowing ring
            // Glowing ring
            const ringGeom = new THREE.RingGeometry(0.3, 0.4, 32);
            ringGeom.rotateX(-Math.PI / 2);
            const ringMat = new THREE.MeshBasicMaterial({
                color: 0x00ff00,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.7,
                depthTest: false // Fix z-fighting
            });
            const ring = new THREE.Mesh(ringGeom, ringMat);
            ring.renderOrder = 1; // Render on top of ground
            group.add(ring);

            // Arrow Sprite
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            // Clear
            ctx.clearRect(0, 0, 128, 128);
            // Draw Arrow
            ctx.font = '80px Arial';
            ctx.fillStyle = '#00ff00';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowColor = "#00ff00";
            ctx.shadowBlur = 10;
            ctx.fillText('â¬†ï¸', 64, 64);

            const tex = new THREE.CanvasTexture(canvas);
            const spriteMat = new THREE.SpriteMaterial({ map: tex, transparent: true });
            const sprite = new THREE.Sprite(spriteMat);
            sprite.position.set(0, 0.5, 0);
            sprite.scale.set(0.6, 0.6, 1);
            group.add(sprite);

            teleportMarker = group;
            teleportMarker.visible = false;
            scene.add(teleportMarker);
        }

        function createInteractionMarker() {
            const group = new THREE.Group();
            // Hand Sprite
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.font = '80px Arial';
            ctx.fillStyle = '#ffff00';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowColor = "#ffff00";
            ctx.shadowBlur = 10;
            ctx.fillText('ðŸ‘†', 64, 64);

            const tex = new THREE.CanvasTexture(canvas);
            const spriteMat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthTest: false });
            const sprite = new THREE.Sprite(spriteMat);
            sprite.scale.set(0.5, 0.5, 1);
            group.add(sprite);

            interactionMarker = group;
            interactionMarker.visible = false;
            scene.add(interactionMarker);
        }



        function checkInteractions() {
            const raycaster = new THREE.Raycaster();
            const camWorldPos = new THREE.Vector3();
            camera.getWorldPosition(camWorldPos);
            const lookDir = new THREE.Vector3();
            camera.getWorldDirection(lookDir);

            raycaster.set(camWorldPos, lookDir);
            raycaster.far = 20;

            // Reset State
            hoverState = { type: 'none', object: null, point: null };
            teleportMarker.visible = false;
            canTeleport = false;
            interactionMarker.visible = false;
            reticle.material.color.setHex(0xffffff);

            // Raycast against EVERYTHING that matters
            const allObjects = [...interactables, ...colliders, ground];
            const intersects = raycaster.intersectObjects(allObjects);

            if (intersects.length > 0) {
                const hit = intersects[0];
                const object = hit.object;
                const distance = hit.distance; // Distance from camera

                // 1. Hit a Collider (Wall) first? -> Block everything
                if (colliders.includes(object)) {
                    // Check if it is a door (which is also a collider)
                    if (object.userData.type === 'door' && distance < 5.0) {
                        // It's a door in range
                        interactionMarker.position.copy(hit.point);
                        interactionMarker.lookAt(camera.position); // Billboard
                        interactionMarker.visible = true;
                        hoverState = { type: 'interact', object: object };
                        reticle.material.color.setHex(0xffff00);
                        info.textContent = "Klicken zum Ã–ffnen";
                    } else {
                        // It's a wall or far door -> Block
                        reticle.material.color.setHex(0xffffff);
                        info.textContent = "";
                    }
                }
                // 2. Hit an Interactable (Interactable includes Door, but Door was handled above if in colliders. 
                //    Wait, Door is in BOTH. intersectObjects returns it once. 
                //    If logic above handles 'door' inside colliders check, we are good.
                //    What if it's a gift box? Gift box is NOT in colliders, so it falls here.
                else if (interactables.includes(object)) {
                    if (distance < 5.0) {
                        if ((object.userData.type === 'gift' && !boxOpened) ||
                            (object.userData.type === 'shelf' && !shelfOpened) ||
                            (object.userData.type === 'cyber' && !cyberOpened)) {
                            interactionMarker.position.copy(hit.point);
                            interactionMarker.visible = true;
                            hoverState = { type: 'interact', object: object };
                            reticle.material.color.setHex(0xffff00);
                            info.textContent = "Klicken zum Interagieren";
                        }
                    }
                }
                // 3. Hit Ground? -> Teleport
                else if (object === ground) {
                    // Reduce max distance logic
                    if (distance < 7.5) {
                        teleportMarker.position.copy(hit.point);
                        teleportMarker.position.y += 0.05;
                        teleportMarker.visible = true;
                        canTeleport = true;
                        hoverState = { type: 'teleport', point: hit.point };
                        reticle.material.color.setHex(0x00ff00);
                    }
                }
            }

            // Update Reticle Position
            const reticlePos = new THREE.Vector3();
            reticlePos.copy(camWorldPos).add(lookDir.multiplyScalar(2));
            reticle.position.copy(reticlePos);
            reticle.lookAt(camWorldPos);
        }

        function openGift() {
            if (boxOpened) return;
            boxOpened = true;
            let lidY = 0.25;
            const lid = giftBoxLid;
            const anim = setInterval(() => {
                lidY += 0.05;
                lid.position.y = lidY;
                lid.rotation.z += 0.1;
                if (lidY > 1.0) {
                    clearInterval(anim);
                    showGift();
                }
            }, 30);
        }

        function showGift() {
            const geom = new THREE.SphereGeometry(0.3, 32, 32);
            const mat = new THREE.MeshStandardMaterial({
                color: 0x00ffff,
                emissive: 0x0088ff,
                emissiveIntensity: 2,
                roughness: 0,
                metalness: 1
            });
            const orb = new THREE.Mesh(geom, mat);
            orb.position.set(0, 0.5, 0);
            giftBox.parent.add(orb);

            const orbLight = new THREE.PointLight(0x00ffff, 5, 10);
            orbLight.position.set(0, 0, 0);
            orb.add(orbLight);

            const canvas = document.createElement('canvas');
            canvas.width = 1024; canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // 1. Clear with transparent background
            ctx.clearRect(0, 0, 1024, 512);

            // 2. Draw Text with Glow
            ctx.font = 'bold 80px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // Glow effect
            ctx.shadowColor = "#00ffff";
            ctx.shadowBlur = 15;
            ctx.lineWidth = 4;
            ctx.strokeStyle = '#0088ff';
            ctx.strokeText("ðŸŽ‰ HAPPY BIRTHDAY! ðŸŽ‰", 512, 200);
            ctx.strokeText("Hier ist dein VR-Erlebnis!", 512, 300);

            // White text body
            ctx.shadowBlur = 0;
            ctx.fillStyle = '#ffffff';
            ctx.fillText("ðŸŽ‰ HAPPY BIRTHDAY! ðŸŽ‰", 512, 200);
            ctx.fillText("Hier ist dein VR-Erlebnis!", 512, 300);

            const textTex = new THREE.CanvasTexture(canvas);

            // 3. Material: AdditiveBlending + AlphaTest
            // This ensures transparent parts don't occlude anything (black wall fix)
            const textMat = new THREE.SpriteMaterial({
                map: textTex,
                transparent: true,
                alphaTest: 0.1,
                depthWrite: false,
                depthTest: false, // FORCE it to render on top of everything (no occlusion)
                blending: THREE.AdditiveBlending
            });

            const textSprite = new THREE.Sprite(textMat);
            textSprite.scale.set(3, 1.5, 1);
            textSprite.position.set(0, 1.2, 0);
            textSprite.renderOrder = 9999; // Very high render order
            giftBox.parent.add(textSprite);

            let time = 0;
            const anim = setInterval(() => {
                time += 0.05;
                orb.position.y = 1.0 + Math.sin(time) * 0.2;
                textSprite.position.y = 1.2 + Math.sin(time * 0.5) * 0.1; // Animated around lower height
                const hue = (time * 0.1) % 1;
                mat.emissive.setHSL(hue, 1, 0.5);
                orbLight.color.setHSL(hue, 1, 0.5);
                spawnConfetti(new THREE.Vector3().setFromMatrixPosition(orb.matrixWorld));
            }, 30);

            info.style.display = 'none';
        }

        function openShelf() {
            if (shelfOpened) return;
            shelfOpened = true;
            const door = shelfDoor;
            let rotY = 0;

            // Find Witcher sprite
            const witcherSprite = door.parent.getObjectByName('witcherSprite');

            const anim = setInterval(() => {
                rotY -= 0.05;
                door.rotation.y = rotY;

                // Move sprite forward (Z axis in shelf local space)
                if (witcherSprite && witcherSprite.position.z < 0.8) {
                    witcherSprite.position.z += 0.015;
                }

                if (rotY < -2.0) {
                    clearInterval(anim);

                    // Show Witcher Text
                    const canvas = document.createElement('canvas');
                    canvas.width = 1024; canvas.height = 256;
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, 1024, 256);

                    ctx.font = 'bold 50px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';

                    ctx.shadowColor = "#ff0000";
                    ctx.shadowBlur = 15;
                    ctx.lineWidth = 3;
                    ctx.strokeStyle = '#880000';
                    ctx.strokeText("BOOH! ICH HABE LEIDER", 512, 100);
                    ctx.strokeText("KEINE BRATPFANNE FÃœR DICH!", 512, 180);

                    ctx.shadowBlur = 0;
                    ctx.fillStyle = '#ffcccc';
                    ctx.fillText("BOOH! ICH HABE LEIDER", 512, 100);
                    ctx.fillText("KEINE BRATPFANNE FÃœR DICH!", 512, 180);

                    const textTex = new THREE.CanvasTexture(canvas);
                    const textMat = new THREE.SpriteMaterial({
                        map: textTex,
                        transparent: true,
                        alphaTest: 0.1,
                        depthWrite: false,
                        depthTest: false,
                        blending: THREE.AdditiveBlending
                    });

                    const textSprite = new THREE.Sprite(textMat);
                    textSprite.scale.set(4, 1, 1);
                    textSprite.position.set(0, 1.5, 0); // Position text ABOVE the shelf
                    textSprite.renderOrder = 9999;

                    shelfDoor.parent.add(textSprite);
                }
            }, 30);
        }

        function openCyber(lidObject) {
            if (cyberOpened) return;
            cyberOpened = true;

            const lidGroup = lidObject.userData.lid;
            const sprite = lidObject.userData.sprite;

            let rotX = 0;
            const anim = setInterval(() => {
                rotX -= 0.05;
                lidGroup.rotation.x = rotX;

                if (rotX < -2.0) {
                    clearInterval(anim);
                    sprite.visible = true; // Show Johnny

                    // Show Text
                    const canvas = document.createElement('canvas');
                    canvas.width = 1024; canvas.height = 256;
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, 1024, 256);

                    ctx.font = 'bold 50px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';

                    // Cyber Style: Yellow/Blue
                    ctx.shadowColor = "#f0f";
                    ctx.shadowBlur = 15;
                    ctx.lineWidth = 3;
                    ctx.strokeStyle = '#00ffff';
                    ctx.strokeText("NO, YOU ARE AWESOME", 512, 100);
                    ctx.strokeText("MR SITTIGSON!", 512, 180);

                    ctx.shadowBlur = 0;
                    ctx.fillStyle = '#ffff00'; // Cyberpunk Yellow
                    ctx.fillText("NO, YOU ARE AWESOME", 512, 100);
                    ctx.fillText("MR SITTIGSON!", 512, 180);

                    const textTex = new THREE.CanvasTexture(canvas);
                    const textMat = new THREE.SpriteMaterial({
                        map: textTex,
                        transparent: true,
                        alphaTest: 0.1,
                        depthWrite: false,
                        depthTest: false,
                        blending: THREE.AdditiveBlending
                    });

                    const textSprite = new THREE.Sprite(textMat);
                    textSprite.scale.set(4, 1, 1);
                    textSprite.position.set(0, 3.0, 0); // Moved higher to 3.0
                    textSprite.renderOrder = 9999;

                    lidGroup.parent.add(textSprite);
                    info.textContent = "ðŸ˜Ž WAKE UP SAMURAI!";
                }
            }, 30);
        }

        function spawnConfetti(pos) {
            const geom = new THREE.BufferGeometry();
            const count = 10;
            const positions = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);
            const vels = [];
            for (let i = 0; i < count; i++) {
                positions[i * 3] = pos.x;
                positions[i * 3 + 1] = pos.y;
                positions[i * 3 + 2] = pos.z;
                vels.push({
                    x: (Math.random() - 0.5) * 0.3,
                    y: (Math.random() - 0.5) * 0.3 + 0.2,
                    z: (Math.random() - 0.5) * 0.3
                });
                const color = new THREE.Color().setHSL(Math.random(), 1, 0.5);
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
            }
            geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geom.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            const mat = new THREE.PointsMaterial({ size: 0.05, vertexColors: true });
            const sys = new THREE.Points(geom, mat);
            scene.add(sys);
            let frame = 0;
            const anim = setInterval(() => {
                const posAttr = sys.geometry.attributes.position;
                for (let i = 0; i < count; i++) {
                    posAttr.setXYZ(i,
                        posAttr.getX(i) + vels[i].x,
                        posAttr.getY(i) + vels[i].y,
                        posAttr.getZ(i) + vels[i].z
                    );
                    vels[i].y -= 0.01;
                }
                posAttr.needsUpdate = true;
                frame++;
                if (frame > 60) { clearInterval(anim); scene.remove(sys); }
            }, 30);
        }

        let mouseX = 0, mouseY = 0;
        let moveForward = false;
        let moveBackward = false;
        let isDragging = false;
        let lastTouchX = 0, lastTouchY = 0;

        function setupDesktopControls() {
            document.addEventListener('mousedown', () => isDragging = true);
            document.addEventListener('mouseup', () => isDragging = false);
            document.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    mouseX -= e.movementX * 0.002;
                    mouseY -= e.movementY * 0.002;
                    mouseY = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, mouseY));
                }
            });
            document.addEventListener('touchstart', (e) => {
                moveForward = true;
                lastTouchX = e.touches[0].clientX;
                lastTouchY = e.touches[0].clientY;
            });
            document.addEventListener('touchend', () => moveForward = false);
            document.addEventListener('keydown', (e) => {
                if (e.key === 'w' || e.key === 'ArrowUp') moveForward = true;
                if (e.key === 's' || e.key === 'ArrowDown') moveBackward = true;
            });
            document.addEventListener('keyup', (e) => {
                if (e.key === 'w' || e.key === 'ArrowUp') moveForward = false;
                if (e.key === 's' || e.key === 'ArrowDown') moveBackward = false;
            });
        }

        function animate() {
            if (!renderer.xr.isPresenting) {
                if (deviceControls) {
                    deviceControls.update();
                } else {
                    camera.rotation.order = 'YXZ';
                    camera.rotation.y = mouseX;
                    camera.rotation.x = mouseY;
                }
                const dir = new THREE.Vector3();
                camera.getWorldDirection(dir);
                if (!isGodMode) {
                    dir.y = 0; // Flatten movement if not flying
                }
                dir.normalize();
                if (moveForward) {
                    userGroup.position.add(dir.multiplyScalar(0.08));
                }
                if (moveBackward) {
                    userGroup.position.sub(dir.multiplyScalar(0.08));
                }
            }
            checkInteractions();
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>

</html>