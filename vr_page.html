<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VR Geburtstagsgeschenk</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #000;
        }

        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-size: 16px;
            z-index: 100;
            pointer-events: none;
        }

        #startButton {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px 40px;
            font-size: 20px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            z-index: 200;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        #startButton:hover {
            background: #45a049;
        }

        #vrButton {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 15px 30px;
            font-size: 18px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            z-index: 100;
            display: none;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        #vrButton:hover {
            background: #0b7dda;
        }
    </style>
</head>

<body>
    <div id="info">Schaue dich um und bewege dich zur TÃ¼r!</div>
    <button id="startButton">Erlebnis starten</button>
    <button id="vrButton">VR-Modus starten</button>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { VRButton } from 'three/addons/webxr/VRButton.js';

        // --- Inline DeviceOrientationControls Implementation ---
        class DeviceOrientationControls {
            constructor(object) {
                this.object = object;
                this.object.rotation.reorder("YXZ");
                this.enabled = true;
                this.deviceOrientation = {};
                this.screenOrientation = 0;
                this.alphaOffset = 0;

                this.onDeviceOrientationChangeEvent = (event) => {
                    this.deviceOrientation = event;
                };

                this.onScreenOrientationChangeEvent = () => {
                    this.screenOrientation = window.orientation || 0;
                };

                window.addEventListener('deviceorientation', this.onDeviceOrientationChangeEvent, false);
                window.addEventListener('orientationchange', this.onScreenOrientationChangeEvent, false);

                this.onScreenOrientationChangeEvent();
            }

            update() {
                if (!this.enabled) return;
                const device = this.deviceOrientation;
                if (device) {
                    const alpha = device.alpha ? THREE.MathUtils.degToRad(device.alpha) + this.alphaOffset : 0;
                    const beta = device.beta ? THREE.MathUtils.degToRad(device.beta) : 0;
                    const gamma = device.gamma ? THREE.MathUtils.degToRad(device.gamma) : 0;
                    const orient = this.screenOrientation ? THREE.MathUtils.degToRad(this.screenOrientation) : 0;

                    this.setObjectQuaternion(this.object.quaternion, alpha, beta, gamma, orient);
                }
            }

            setObjectQuaternion(quaternion, alpha, beta, gamma, orient) {
                const zee = new THREE.Vector3(0, 0, 1);
                const euler = new THREE.Euler();
                const q0 = new THREE.Quaternion();
                const q1 = new THREE.Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5));

                euler.set(beta, alpha, -gamma, 'YXZ');
                quaternion.setFromEuler(euler);
                quaternion.multiply(q1);
                quaternion.multiply(q0.setFromAxisAngle(zee, -orient));
            }

            dispose() {
                window.removeEventListener('deviceorientation', this.onDeviceOrientationChangeEvent);
                window.removeEventListener('orientationchange', this.onScreenOrientationChangeEvent);
            }
        }
        // -------------------------------------------------------

        let scene, camera, renderer, reticle;
        let deviceControls;
        let boxOpened = false;
        let shelfOpened = false;
        let vrSupported = false;
        let isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);

        let interactables = [];
        let giftBox, giftBoxLid, shelfDoor;
        let cyberOpened = false;

        const startButton = document.getElementById('startButton');
        const vrButton = document.getElementById('vrButton');
        const info = document.getElementById('info');

        startButton.addEventListener('click', init);

        // texture generation
        const textures = {};

        function generateTextures() {
            // 1. Neon Grid / Cobblestone Floor
            const canvasFloor = document.createElement('canvas');
            canvasFloor.width = 512; canvasFloor.height = 512;
            const ctxFloor = canvasFloor.getContext('2d');
            ctxFloor.fillStyle = '#111';
            ctxFloor.fillRect(0, 0, 512, 512);
            ctxFloor.strokeStyle = '#0ff';
            ctxFloor.lineWidth = 2;
            ctxFloor.shadowBlur = 10;
            ctxFloor.shadowColor = '#0ff';
            for (let i = 0; i <= 512; i += 64) {
                ctxFloor.beginPath(); ctxFloor.moveTo(i, 0); ctxFloor.lineTo(i, 512); ctxFloor.stroke();
                ctxFloor.beginPath(); ctxFloor.moveTo(0, i); ctxFloor.lineTo(512, i); ctxFloor.stroke();
            }
            textures.floor = new THREE.CanvasTexture(canvasFloor);
            textures.floor.wrapS = THREE.RepeatWrapping;
            textures.floor.wrapT = THREE.RepeatWrapping;
            textures.floor.repeat.set(10, 10);

            // 2. Rustic Wood
            const canvasWood = document.createElement('canvas');
            canvasWood.width = 512; canvasWood.height = 512;
            const ctxWood = canvasWood.getContext('2d');
            ctxWood.fillStyle = '#3e2723';
            ctxWood.fillRect(0, 0, 512, 512);
            for (let i = 0; i < 50; i++) {
                ctxWood.strokeStyle = '#281a15';
                ctxWood.lineWidth = Math.random() * 5 + 1;
                ctxWood.beginPath();
                ctxWood.moveTo(0, Math.random() * 512);
                ctxWood.bezierCurveTo(150, Math.random() * 512, 350, Math.random() * 512, 512, Math.random() * 512);
                ctxWood.stroke();
            }
            textures.wood = new THREE.CanvasTexture(canvasWood);

            // 3. Neon Glyphs
            const canvasNeon = document.createElement('canvas');
            canvasNeon.width = 128; canvasNeon.height = 128;
            const ctxNeon = canvasNeon.getContext('2d');
            ctxNeon.fillStyle = '#000';
            ctxNeon.fillRect(0, 0, 128, 128);
            ctxNeon.strokeStyle = '#f0f';
            ctxNeon.lineWidth = 5;
            ctxNeon.shadowBlur = 15;
            ctxNeon.shadowColor = '#f0f';
            ctxNeon.strokeRect(10, 10, 108, 108);
            ctxNeon.font = '80px Arial';
            ctxNeon.fillStyle = '#f0f';
            ctxNeon.textAlign = 'center';
            ctxNeon.textBaseline = 'middle';
            // ctxNeon.fillText('RUN', 64, 64);
            textures.neon = new THREE.CanvasTexture(canvasNeon);

            // 4. Witcher Sprite
            const canvasWitcher = document.createElement('canvas');
            canvasWitcher.width = 256; canvasWitcher.height = 512;
            const ctxW = canvasWitcher.getContext('2d');
            ctxW.clearRect(0, 0, 256, 512);
            ctxW.fillStyle = '#222';
            ctxW.fillRect(80, 150, 96, 200);
            ctxW.fillStyle = '#ffccaa';
            ctxW.fillRect(100, 80, 56, 70);
            ctxW.fillStyle = '#eee';
            ctxW.fillRect(90, 80, 76, 40);
            ctxW.fillRect(90, 80, 20, 100);
            ctxW.fillStyle = '#aaa';
            ctxW.fillRect(180, 100, 10, 250);
            ctxW.fillRect(66, 100, 10, 250);
            ctxW.fillStyle = '#fb0';
            ctxW.fillRect(110, 110, 10, 6);
            ctxW.fillRect(136, 110, 10, 6);
            textures.witcher = new THREE.CanvasTexture(canvasWitcher);

            // 5. Johnny Silverhand Image (Load from file)
            const loader = new THREE.TextureLoader();
            textures.johnny = loader.load('johnny.png');
            textures.johnny.colorSpace = THREE.SRGBColorSpace;
        }

        async function init() {
            generateTextures();
            startButton.style.display = 'none';

            if (navigator.xr) {
                vrSupported = await navigator.xr.isSessionSupported('immersive-vr');
            }

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050510);
            scene.fog = new THREE.FogExp2(0x050510, 0.02);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.6, 10);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);

            if (vrSupported) {
                const vrBtn = VRButton.createButton(renderer);
                vrBtn.style.bottom = '20px';
                vrBtn.style.left = '50%';
                vrBtn.style.transform = 'translateX(-50%)';
                document.body.appendChild(vrBtn);
                info.textContent = 'Starte den VR-Modus und schaue dich um!';
            } else if (isMobile) {
                vrButton.style.display = 'none';
                info.textContent = 'Bewege dein Handy um dich umzusehen! Tippe zum Laufen.';
                if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                    DeviceOrientationEvent.requestPermission()
                        .then(response => {
                            if (response == 'granted') {
                                deviceControls = new DeviceOrientationControls(camera);
                            }
                        })
                        .catch(console.error);
                } else {
                    deviceControls = new DeviceOrientationControls(camera);
                }
            } else {
                vrButton.style.display = 'block';
                vrButton.textContent = 'Desktop Modus Aktiv';
                info.textContent = 'Nutze Maus (Klick+Ziehen) und WASD/Pfeile zum Bewegen';
            }

            const ambientLight = new THREE.AmbientLight(0x4040a0, 1.0);
            scene.add(ambientLight);

            const sunLight = new THREE.DirectionalLight(0xff00ff, 1.5);
            sunLight.position.set(-10, 20, -10);
            sunLight.castShadow = true;
            scene.add(sunLight);

            const pointLight = new THREE.PointLight(0x00ffff, 2, 20);
            pointLight.position.set(0, 5, 5);
            scene.add(pointLight);

            createEnvironment();
            createVillage();
            createReticle();

            setupDesktopControls();

            renderer.setAnimationLoop(animate);
            window.addEventListener('resize', onWindowResize);
        }

        function createEnvironment() {
            const groundGeometry = new THREE.PlaneGeometry(100, 100);
            const groundMaterial = new THREE.MeshStandardMaterial({
                map: textures.floor,
                roughness: 0.2,
                metalness: 0.6
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            const particlesGeom = new THREE.BufferGeometry();
            const particleCount = 200;
            const positions = new Float32Array(particleCount * 3);
            for (let i = 0; i < particleCount * 3; i++) {
                positions[i] = (Math.random() - 0.5) * 60;
                if (i % 3 === 1) positions[i] = Math.random() * 10;
            }
            particlesGeom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const particlesMat = new THREE.PointsMaterial({ color: 0x00ffff, size: 0.2, transparent: true, opacity: 0.8 });
            const particles = new THREE.Points(particlesGeom, particlesMat);
            scene.add(particles);
        }

        function createVillage() {
            createHouse(0, 0, -5, 0, false, false, true); // Middle House -> Johnny
            createHouse(-10, 0, 0, Math.PI / 4, false, true, false);
            createHouse(12, 0, -2, -Math.PI / 6, false, false, false);
            createHouse(-8, 0, -15, Math.PI / 3, true, false, false);
        }

        function createHouse(x, y, z, rotation, isMain, isSecret, isCyber) {
            const houseGroup = new THREE.Group();
            const wallMaterial = new THREE.MeshStandardMaterial({ map: textures.wood });
            const darkMaterial = new THREE.MeshStandardMaterial({ color: 0x1a1a1a });

            const mainBody = new THREE.Mesh(new THREE.BoxGeometry(4, 3, 4), wallMaterial);
            mainBody.position.y = 1.5;
            mainBody.castShadow = true;
            mainBody.receiveShadow = true;
            houseGroup.add(mainBody);

            const roof = new THREE.Mesh(new THREE.ConeGeometry(3.5, 2, 4), darkMaterial);
            roof.position.y = 4;
            roof.rotation.y = Math.PI / 4;
            houseGroup.add(roof);

            const doorFrame = new THREE.Mesh(new THREE.BoxGeometry(1.6, 2.2, 0.2), new THREE.MeshBasicMaterial({ map: textures.neon }));
            doorFrame.position.set(0, 1.1, 2.01);
            houseGroup.add(doorFrame);

            if (isMain) {
                createTableAndGift(houseGroup);
            } else if (isSecret) {
                createSecretShelf(houseGroup);
            } else if (isCyber) {
                createCyberpunkConsole(houseGroup);
            }

            houseGroup.position.set(x, y, z);
            houseGroup.rotation.y = rotation;
            scene.add(houseGroup);
        }

        // ... (createTableAndGift and createSecretShelf remain same) ...

        function createCyberpunkConsole(parentGroup) {
            const consoleGroup = new THREE.Group();

            // Base module
            const base = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1, 0.8), new THREE.MeshStandardMaterial({ map: textures.neon, color: 0x333333 }));
            base.position.y = 0.5;
            consoleGroup.add(base);

            // Screen / Lid
            const lidGroup = new THREE.Group();
            lidGroup.position.set(0, 1.0, -0.4); // Hinge at back

            const lid = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.1, 0.8), new THREE.MeshStandardMaterial({ map: textures.neon, emissive: 0x222222 }));
            lid.position.set(0, 0, 0.4); // Offset so it rotates from edge
            lidGroup.add(lid);

            consoleGroup.add(lidGroup);

            // Johnny Sprite (Hidden initially)
            const spriteMat = new THREE.SpriteMaterial({ map: textures.johnny });
            const johnnySprite = new THREE.Sprite(spriteMat);
            johnnySprite.scale.set(1.5, 1.5, 1); // Square aspect ratio
            johnnySprite.position.set(0, 1.5, 0);
            johnnySprite.visible = false;
            consoleGroup.add(johnnySprite);

            consoleGroup.position.set(0, 0, 0);
            parentGroup.add(consoleGroup);

            // Interaction Tag
            lid.userData = { type: 'cyber', parent: consoleGroup, lid: lidGroup, sprite: johnnySprite };
            interactables.push(lid);
        }

        function createTableAndGift(parentGroup) {
            const table = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.8, 1), new THREE.MeshStandardMaterial({ map: textures.wood }));
            table.position.set(0, 0.4, 0);
            parentGroup.add(table);

            const boxGroup = new THREE.Group();
            const boxMat = new THREE.MeshStandardMaterial({ color: 0xff0044, roughness: 0.3 });
            const lidMat = new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.8 });

            giftBox = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), boxMat);
            boxGroup.add(giftBox);

            giftBoxLid = new THREE.Mesh(new THREE.BoxGeometry(0.55, 0.1, 0.55), lidMat);
            giftBoxLid.position.y = 0.25;
            boxGroup.add(giftBoxLid);

            boxGroup.position.set(0, 1.0, 0);
            parentGroup.add(boxGroup);

            giftBox.userData = { type: 'gift', parent: boxGroup };
            interactables.push(giftBox);
        }

        function createSecretShelf(parentGroup) {
            const shelfGroup = new THREE.Group();
            const body = new THREE.Mesh(new THREE.BoxGeometry(1, 1.5, 0.5), new THREE.MeshStandardMaterial({ map: textures.wood, color: 0x888888 }));
            shelfGroup.add(body);

            const doorGroup = new THREE.Group();
            doorGroup.position.set(-0.45, 0, 0.26);

            shelfDoor = new THREE.Mesh(new THREE.BoxGeometry(0.9, 1.4, 0.1), new THREE.MeshStandardMaterial({ map: textures.wood }));
            shelfDoor.position.set(0.45, 0, 0);
            doorGroup.add(shelfDoor);

            shelfGroup.add(doorGroup);
            shelfDoor = doorGroup; // Override for animation

            const spriteMat = new THREE.SpriteMaterial({ map: textures.witcher });
            const witcherSprite = new THREE.Sprite(spriteMat);
            witcherSprite.scale.set(0.7, 1.4, 1);
            witcherSprite.position.set(0, 0, 0.3);
            witcherSprite.name = 'witcherSprite'; // Add name for access
            shelfGroup.add(witcherSprite);

            shelfGroup.position.set(0, 1.2, 0);
            parentGroup.add(shelfGroup);

            doorGroup.children[0].userData = { type: 'shelf', parent: shelfGroup };
            interactables.push(doorGroup.children[0]);
        }

        function createReticle() {
            const reticleGeometry = new THREE.RingGeometry(0.02, 0.04, 32);
            const reticleMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, opacity: 0.8, transparent: true });
            reticle = new THREE.Mesh(reticleGeometry, reticleMaterial);
            reticle.visible = false;
            scene.add(reticle);
        }

        function checkInteractions() {
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera({ x: 0, y: 0 }, camera);
            raycaster.far = 10;

            const lookDir = new THREE.Vector3();
            camera.getWorldDirection(lookDir);
            reticle.position.copy(camera.position).add(lookDir.multiplyScalar(2));
            reticle.lookAt(camera.position);

            const intersects = raycaster.intersectObjects(interactables);

            if (intersects.length > 0) {
                const object = intersects[0].object;
                const type = object.userData.type;
                reticle.material.color.setHex(0xff0000);
                const dist = intersects[0].distance;

                if (dist < 4.0) {
                    if (type === 'gift' && !boxOpened) {
                        info.textContent = "Geschenk gefunden! Es Ã¶ffnet sich...";
                        openGift();
                    } else if (type === 'shelf' && !shelfOpened) {
                        info.textContent = "Geheimnis entdeckt...";
                        openShelf();
                    } else if (type === 'cyber' && !cyberOpened) {
                        info.textContent = "System wird gehackt...";
                        openCyber(object);
                    }
                } else {
                    info.textContent = "Geh nÃ¤her ran!";
                }
            } else {
                reticle.material.color.setHex(0xffffff);
                info.textContent = isMobile ? "Bewege dein Handy und tippe zum Laufen" : "Suche in den HÃ¤usern!";
            }
        }

        function openGift() {
            if (boxOpened) return;
            boxOpened = true;
            let lidY = 0.25;
            const lid = giftBoxLid;
            const anim = setInterval(() => {
                lidY += 0.05;
                lid.position.y = lidY;
                lid.rotation.z += 0.1;
                if (lidY > 1.0) {
                    clearInterval(anim);
                    showGift();
                }
            }, 30);
        }

        function showGift() {
            const geom = new THREE.SphereGeometry(0.3, 32, 32);
            const mat = new THREE.MeshStandardMaterial({
                color: 0x00ffff,
                emissive: 0x0088ff,
                emissiveIntensity: 2,
                roughness: 0,
                metalness: 1
            });
            const orb = new THREE.Mesh(geom, mat);
            orb.position.set(0, 0.5, 0);
            giftBox.parent.add(orb);

            const orbLight = new THREE.PointLight(0x00ffff, 5, 10);
            orbLight.position.set(0, 0, 0);
            orb.add(orbLight);

            const canvas = document.createElement('canvas');
            canvas.width = 1024; canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // 1. Clear with transparent background
            ctx.clearRect(0, 0, 1024, 512);

            // 2. Draw Text with Glow
            ctx.font = 'bold 80px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // Glow effect
            ctx.shadowColor = "#00ffff";
            ctx.shadowBlur = 15;
            ctx.lineWidth = 4;
            ctx.strokeStyle = '#0088ff';
            ctx.strokeText("ðŸŽ‰ HAPPY BIRTHDAY! ðŸŽ‰", 512, 200);
            ctx.strokeText("Hier ist dein VR-Erlebnis!", 512, 300);

            // White text body
            ctx.shadowBlur = 0;
            ctx.fillStyle = '#ffffff';
            ctx.fillText("ðŸŽ‰ HAPPY BIRTHDAY! ðŸŽ‰", 512, 200);
            ctx.fillText("Hier ist dein VR-Erlebnis!", 512, 300);

            const textTex = new THREE.CanvasTexture(canvas);

            // 3. Material: AdditiveBlending + AlphaTest
            // This ensures transparent parts don't occlude anything (black wall fix)
            const textMat = new THREE.SpriteMaterial({
                map: textTex,
                transparent: true,
                alphaTest: 0.1,
                depthWrite: false,
                depthTest: false, // FORCE it to render on top of everything (no occlusion)
                blending: THREE.AdditiveBlending
            });

            const textSprite = new THREE.Sprite(textMat);
            textSprite.scale.set(3, 1.5, 1);
            textSprite.position.set(0, 1.2, 0);
            textSprite.renderOrder = 9999; // Very high render order
            giftBox.parent.add(textSprite);

            let time = 0;
            const anim = setInterval(() => {
                time += 0.05;
                orb.position.y = 1.0 + Math.sin(time) * 0.2;
                textSprite.position.y = 1.2 + Math.sin(time * 0.5) * 0.1; // Animated around lower height
                const hue = (time * 0.1) % 1;
                mat.emissive.setHSL(hue, 1, 0.5);
                orbLight.color.setHSL(hue, 1, 0.5);
                spawnConfetti(new THREE.Vector3().setFromMatrixPosition(orb.matrixWorld));
            }, 30);

            info.style.display = 'none';
        }

        function openShelf() {
            if (shelfOpened) return;
            shelfOpened = true;
            const door = shelfDoor;
            let rotY = 0;

            // Find Witcher sprite
            const witcherSprite = door.parent.getObjectByName('witcherSprite');

            const anim = setInterval(() => {
                rotY -= 0.05;
                door.rotation.y = rotY;

                // Move sprite forward (Z axis in shelf local space)
                if (witcherSprite && witcherSprite.position.z < 0.8) {
                    witcherSprite.position.z += 0.015;
                }

                if (rotY < -2.0) {
                    clearInterval(anim);

                    // Show Witcher Text
                    const canvas = document.createElement('canvas');
                    canvas.width = 1024; canvas.height = 256;
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, 1024, 256);

                    ctx.font = 'bold 50px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';

                    ctx.shadowColor = "#ff0000";
                    ctx.shadowBlur = 15;
                    ctx.lineWidth = 3;
                    ctx.strokeStyle = '#880000';
                    ctx.strokeText("BOOH! ICH HABE LEIDER", 512, 100);
                    ctx.strokeText("KEINE BRATPFANNE FÃœR DICH!", 512, 180);

                    ctx.shadowBlur = 0;
                    ctx.fillStyle = '#ffcccc';
                    ctx.fillText("BOOH! ICH HABE LEIDER", 512, 100);
                    ctx.fillText("KEINE BRATPFANNE FÃœR DICH!", 512, 180);

                    const textTex = new THREE.CanvasTexture(canvas);
                    const textMat = new THREE.SpriteMaterial({
                        map: textTex,
                        transparent: true,
                        alphaTest: 0.1,
                        depthWrite: false,
                        depthTest: false,
                        blending: THREE.AdditiveBlending
                    });

                    const textSprite = new THREE.Sprite(textMat);
                    textSprite.scale.set(4, 1, 1);
                    textSprite.position.set(0, 1.5, 0); // Position text ABOVE the shelf
                    textSprite.renderOrder = 9999;

                    shelfDoor.parent.add(textSprite);
                }
            }, 30);
        }

        function openCyber(lidObject) {
            if (cyberOpened) return;
            cyberOpened = true;

            const lidGroup = lidObject.userData.lid;
            const sprite = lidObject.userData.sprite;

            let rotX = 0;
            const anim = setInterval(() => {
                rotX -= 0.05;
                lidGroup.rotation.x = rotX;

                if (rotX < -2.0) {
                    clearInterval(anim);
                    sprite.visible = true; // Show Johnny

                    // Show Text
                    const canvas = document.createElement('canvas');
                    canvas.width = 1024; canvas.height = 256;
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, 1024, 256);

                    ctx.font = 'bold 50px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';

                    // Cyber Style: Yellow/Blue
                    ctx.shadowColor = "#f0f";
                    ctx.shadowBlur = 15;
                    ctx.lineWidth = 3;
                    ctx.strokeStyle = '#00ffff';
                    ctx.strokeText("NO, YOU ARE AWESOME", 512, 100);
                    ctx.strokeText("MR SITTIGSON!", 512, 180);

                    ctx.shadowBlur = 0;
                    ctx.fillStyle = '#ffff00'; // Cyberpunk Yellow
                    ctx.fillText("NO, YOU ARE AWESOME", 512, 100);
                    ctx.fillText("MR SITTIGSON!", 512, 180);

                    const textTex = new THREE.CanvasTexture(canvas);
                    const textMat = new THREE.SpriteMaterial({
                        map: textTex,
                        transparent: true,
                        alphaTest: 0.1,
                        depthWrite: false,
                        depthTest: false,
                        blending: THREE.AdditiveBlending
                    });

                    const textSprite = new THREE.Sprite(textMat);
                    textSprite.scale.set(4, 1, 1);
                    textSprite.position.set(0, 3.0, 0); // Moved higher to 3.0
                    textSprite.renderOrder = 9999;

                    lidGroup.parent.add(textSprite);
                    info.textContent = "ðŸ˜Ž WAKE UP SAMURAI!";
                }
            }, 30);
        }

        function spawnConfetti(pos) {
            const geom = new THREE.BufferGeometry();
            const count = 10;
            const positions = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);
            const vels = [];
            for (let i = 0; i < count; i++) {
                positions[i * 3] = pos.x;
                positions[i * 3 + 1] = pos.y;
                positions[i * 3 + 2] = pos.z;
                vels.push({
                    x: (Math.random() - 0.5) * 0.3,
                    y: (Math.random() - 0.5) * 0.3 + 0.2,
                    z: (Math.random() - 0.5) * 0.3
                });
                const color = new THREE.Color().setHSL(Math.random(), 1, 0.5);
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
            }
            geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geom.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            const mat = new THREE.PointsMaterial({ size: 0.05, vertexColors: true });
            const sys = new THREE.Points(geom, mat);
            scene.add(sys);
            let frame = 0;
            const anim = setInterval(() => {
                const posAttr = sys.geometry.attributes.position;
                for (let i = 0; i < count; i++) {
                    posAttr.setXYZ(i,
                        posAttr.getX(i) + vels[i].x,
                        posAttr.getY(i) + vels[i].y,
                        posAttr.getZ(i) + vels[i].z
                    );
                    vels[i].y -= 0.01;
                }
                posAttr.needsUpdate = true;
                frame++;
                if (frame > 60) { clearInterval(anim); scene.remove(sys); }
            }, 30);
        }

        let mouseX = 0, mouseY = 0;
        let moveForward = false;
        let moveBackward = false;
        let isDragging = false;
        let lastTouchX = 0, lastTouchY = 0;

        function setupDesktopControls() {
            document.addEventListener('mousedown', () => isDragging = true);
            document.addEventListener('mouseup', () => isDragging = false);
            document.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    mouseX -= e.movementX * 0.002;
                    mouseY -= e.movementY * 0.002;
                    mouseY = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, mouseY));
                }
            });
            document.addEventListener('touchstart', (e) => {
                moveForward = true;
                lastTouchX = e.touches[0].clientX;
                lastTouchY = e.touches[0].clientY;
            });
            document.addEventListener('touchend', () => moveForward = false);
            document.addEventListener('keydown', (e) => {
                if (e.key === 'w' || e.key === 'ArrowUp') moveForward = true;
                if (e.key === 's' || e.key === 'ArrowDown') moveBackward = true;
            });
            document.addEventListener('keyup', (e) => {
                if (e.key === 'w' || e.key === 'ArrowUp') moveForward = false;
                if (e.key === 's' || e.key === 'ArrowDown') moveBackward = false;
            });
        }

        function animate() {
            if (!renderer.xr.isPresenting) {
                if (deviceControls) {
                    deviceControls.update();
                } else {
                    camera.rotation.order = 'YXZ';
                    camera.rotation.y = mouseX;
                    camera.rotation.x = mouseY;
                }
                const dir = new THREE.Vector3();
                camera.getWorldDirection(dir);
                dir.y = 0;
                dir.normalize();
                if (moveForward) {
                    camera.position.add(dir.multiplyScalar(0.08));
                    camera.position.y = 1.6;
                }
                if (moveBackward) {
                    camera.position.sub(dir.multiplyScalar(0.08));
                    camera.position.y = 1.6;
                }
            }
            checkInteractions();
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>

</html>